package hfdownloader

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"sync"

	"github.com/cheggaaa/pb/v3"
)

const (
	MaxGoroutines   = 5
	RawFileURL      = "https://huggingface.co/%s/raw/%s/%s"
	LfsResolverURL  = "https://huggingface.co/%s/resolve/%s/%s"
	JsonFileTreeURL = "https://huggingface.co/api/models/%s/tree/%s"
	MinSizeForMulti = 10 * 1024 * 1024 // 10MB
)

func DownloadModel(ModelName string, DestintionBasePath string, silent bool) error {
	modelPath := path.Join(DestintionBasePath, strings.Replace(ModelName, "/", "_", -1))
	//Check StoragePath
	err := os.MkdirAll(modelPath, os.ModePerm)
	if err != nil {
		// fmt.Println("Error:", err)
		return err
	}
	// Send a GET request to the URL

	branch := "main"
	JsonFileListURL := fmt.Sprintf(JsonFileTreeURL, ModelName, branch)
	response, err := http.Get(JsonFileListURL)
	if err != nil {
		// fmt.Println("Error:", err)
		return err
	}
	defer response.Body.Close()

	// Read the response body into a byte slice
	content, err := ioutil.ReadAll(response.Body)
	if err != nil {
		// fmt.Println("Error:", err)
		return err
	}
	// fmt.Println(string(content))
	jsonFilesList := []hfmodel{}
	err = json.Unmarshal(content, &jsonFilesList)
	if err != nil {
		return err
	}
	//1st loop, getting files info and preparing folders
	for i := range jsonFilesList {
		jsonFilesList[i].AppendedPath = path.Join(modelPath, jsonFilesList[i].Path)
		if jsonFilesList[i].Type == "directory" {
			jsonFilesList[i].IsDirectory = true
			err := os.MkdirAll(path.Join(modelPath, jsonFilesList[i].Path), os.ModePerm)
			if err != nil {
				return err
			}
			jsonFilesList[i].SkipDownloading = true
			continue
		}
		jsonFilesList[i].DownloadLink = fmt.Sprintf(RawFileURL, ModelName, branch, jsonFilesList[i].Path)

		if jsonFilesList[i].Lfs != nil {
			jsonFilesList[i].IsLFS = true
			resolverURL := fmt.Sprintf(LfsResolverURL, ModelName, branch, jsonFilesList[i].Path)
			getLink, err := getRedirectLink(resolverURL)
			if err != nil {
				return err
			}
			jsonFilesList[i].DownloadLink = getLink
		}

	}
	// s, _ := json.MarshalIndent(jsonFilesList, "", "  ")
	// fmt.Println(string(s))
	//2nd loop through the files, checking exists/non-exists
	for i := range jsonFilesList {
		//check if the file exists before
		// Check if the file exists
		filename := jsonFilesList[i].AppendedPath
		if _, err := os.Stat(filename); err == nil {
			// File exists, get its size
			fileInfo, _ := os.Stat(filename)
			size := fileInfo.Size()
			//  for non-lfs files, I can only compare size, I don't there is a sha256 hash for them
			if size == int64(jsonFilesList[i].Size) {
				jsonFilesList[i].SkipDownloading = true
				if jsonFilesList[i].IsLFS {
					err := verifyChecksum(jsonFilesList[i].AppendedPath, jsonFilesList[i].Lfs.Oid_SHA265)
					if err != nil {
						err := os.Remove(jsonFilesList[i].AppendedPath)
						if err != nil {
							return err
						}
						jsonFilesList[i].SkipDownloading = false
					}
				}
			}

		}

	}
	//3ed loop through the files, downloading missing/failed files
	for i := range jsonFilesList {
		if jsonFilesList[i].IsDirectory {
			continue
		}
		if jsonFilesList[i].SkipDownloading {
			fmt.Printf("Skipping: %s\n", jsonFilesList[i].AppendedPath)
			continue
		}
		if jsonFilesList[i].IsLFS {
			downloadFile(jsonFilesList[i].DownloadLink, jsonFilesList[i].AppendedPath, jsonFilesList[i].IsLFS, jsonFilesList[i].Lfs.Oid_SHA265)
		} else {
			downloadFile(jsonFilesList[i].DownloadLink, jsonFilesList[i].AppendedPath, jsonFilesList[i].IsLFS, "") //no checksum available for small non-lfs files
		}
	}

	return nil
}

type hfmodel struct {
	Type            string `json:"type"`
	Oid             string `json:"oid"`
	Size            int    `json:"size"`
	Path            string `json:"path"`
	IsDirectory     bool
	IsLFS           bool
	AppendedPath    string
	SkipDownloading bool
	DownloadLink    string
	Lfs             *hflfs `json:"lfs,omitempty"`
}

type hflfs struct {
	Oid_SHA265  string `json:"oid"` // in lfs, oid is sha256 of the file
	Size        int64  `json:"size"`
	PointerSize int    `json:"pointerSize"`
}

// ******************************************************************   All the functions below generated by ChatGPT 3.5, and ChatGPT 4 *********************************************************************
func IsValidModelName(modelName string) bool {
	pattern := `^[A-Za-z0-9\-]+/[A-Za-z0-9\-]+$`
	match, _ := regexp.MatchString(pattern, modelName)
	return match
}

func getRedirectLink(url string) (string, error) {
	client := &http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	resp, err := client.Get(url)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 && resp.StatusCode <= 399 {
		redirectURL := resp.Header.Get("Location")
		return redirectURL, nil
	}

	return "", fmt.Errorf("No redirect found")
}
func downloadFile(fileURL string, destFile string, IsLFS bool, Checksum string) error {
	length := getFileSize(fileURL)
	if length == -1 {
		return fmt.Errorf("Failed to get file size")
	}

	// Create the output file
	outFile, err := os.Create(destFile)
	if err != nil {
		return err
	}
	defer outFile.Close()

	if length > MinSizeForMulti {
		err = downloadMulti(fileURL, filepath.Base(destFile), length, outFile)
	} else {
		err = downloadSingle(fileURL, filepath.Base(destFile), outFile)
	}

	if err != nil {
		fmt.Println("Failed to download file:", err)
		return err
	}

	// Calculate the checksum of the downloaded file in case its LFS
	if IsLFS {
		err = verifyChecksum(outFile.Name(), Checksum)
		if err != nil {
			return fmt.Errorf("Checksum verification failed: %s", err)
		}
	}
	return nil

}
func getFileSize(url string) int {
	resp, err := http.Head(url)
	if err != nil {
		fmt.Println(err)
		return -1
	}

	return int(resp.ContentLength)
}

func downloadSingle(url string, filename string, outFile *os.File) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Progress bar

	// Create a new progress bar with the total size
	bar := pb.Full.Start64(resp.ContentLength)
	bar.SetTemplate(pb.Full)
	bar.Set("prefix", filename)
	barReader := bar.NewProxyReader(resp.Body)

	_, err = io.Copy(outFile, barReader)

	bar.Finish()

	return err
}

func downloadMulti(url string, filename string, length int, outFile *os.File) error {
	bar := pb.StartNew(length)
	bar.Set("prefix", filename)
	partSize := length / MaxGoroutines

	var wg sync.WaitGroup
	errChan := make(chan error, MaxGoroutines)
	for i := 0; i < MaxGoroutines; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()

			start := partSize * i
			end := start + partSize
			if i == MaxGoroutines-1 {
				end = length
			}

			req, _ := http.NewRequest("GET", url, nil)
			req.Header.Set("Range", fmt.Sprintf("bytes=%v-%v", start, end-1))
			resp, err := http.DefaultClient.Do(req)

			defer resp.Body.Close()

			n, err := io.Copy(outFile, resp.Body)
			if err != nil {
				errChan <- err
			}

			// Update the progress bar
			bar.Add(int(n))
		}(i)
	}

	wg.Wait()

	// Finish the progress bar
	bar.Finish()

	select {
	case err := <-errChan:
		return err
	default:
		return nil
	}
}

func verifyChecksum(fileName string, expectedChecksum string) error {
	file, err := os.Open(fileName)
	if err != nil {
		return err
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return err
	}

	sum := hasher.Sum(nil)
	if hex.EncodeToString(sum) != expectedChecksum {
		return fmt.Errorf("checksums do not match")
	}

	return nil
}
